# Architecture Decision Records (ADRs)

This document captures key architectural decisions made during Brain2 backend development, providing context for future maintainers and contributors.

## ADR-001: Domain-Driven Design with Clean Architecture

**Status**: Adopted
**Date**: 2024
**Context**: Need for maintainable, testable backend that can evolve with complex business requirements

### Decision
Implement Domain-Driven Design (DDD) patterns within Clean Architecture boundaries.

### Rationale
- **Business Logic Isolation**: Core business rules remain independent of frameworks and infrastructure
- **Testability**: Domain entities and services can be unit tested without external dependencies
- **Maintainability**: Clear boundaries between layers prevent architectural violations
- **Scalability**: Pattern supports growing complexity as the knowledge graph features expand

### Implementation
- **Domain Layer**: Rich entities (`node.Node`), value objects (`shared.Content`), domain services
- **Application Layer**: Use case orchestration with CQRS pattern separation
- **Infrastructure Layer**: Database, messaging, and external service implementations
- **Interface Layer**: HTTP handlers, WebSocket handlers, CLI interfaces

### Trade-offs
- **Learning Curve**: Team needs DDD knowledge and discipline to maintain patterns
- **Initial Complexity**: More files and abstractions than simple CRUD architecture
- **Development Speed**: Upfront investment in proper layering slows initial development

---

## ADR-002: Command Query Responsibility Segregation (CQRS)

**Status**: Adopted
**Date**: 2024
**Context**: Knowledge graph requires complex read operations with different performance characteristics than writes

### Decision
Separate read and write models using CQRS pattern implementation.

### Rationale
- **Read Optimization**: Graph queries require denormalization, caching, and specialized indexes
- **Write Optimization**: Node creation requires event generation, validation, and connection analysis
- **Scalability**: Read and write sides can be scaled independently
- **Performance**: Complex graph traversals don't impact simple CRUD operations

### Implementation
- **Commands**: `CreateNodeCommand`, `UpdateNodeCommand` with business validation
- **Queries**: `GetNodeQuery`, `GetGraphQuery` with optimized read models
- **Separation**: Different service classes and repository methods for reads vs writes
- **Events**: Write operations generate domain events for eventual consistency

### Trade-offs
- **Complexity**: More classes and interfaces to maintain
- **Consistency**: Eventual consistency model requires careful design
- **Data Duplication**: Read models may duplicate data for optimization

---

## ADR-003: Generic Repository Pattern with Composition

**Status**: Adopted
**Date**: 2024
**Context**: 1,346 lines of duplicated CRUD code across multiple entity repositories

### Decision
Implement generic repository using Go generics with composition pattern.

### Rationale
- **Code Reduction**: 90% reduction in repository boilerplate code
- **Type Safety**: Compile-time type checking maintained through generics
- **Consistency**: All repositories have identical behavior for common operations
- **Maintainability**: Single source of truth for repository patterns

### Implementation
```go
type NodeRepository struct {
    *GenericRepository[*node.Node]  // Composition
    // Add domain-specific methods only
}
```

### Trade-offs
- **Go Generics Requirement**: Requires Go 1.18+ for generics support
- **Learning Curve**: Team needs to understand composition over inheritance patterns
- **Debugging Complexity**: Generic code can be harder to debug and trace

---

## ADR-004: Event-Driven Architecture with EventBridge

**Status**: Adopted
**Date**: 2024
**Context**: Need for real-time graph updates, audit trails, and decoupled system components

### Decision
Use AWS EventBridge for domain event publishing and subscription.

### Rationale
- **Decoupling**: Services communicate through events, not direct calls
- **Scalability**: EventBridge handles fan-out, retries, and dead letter queues
- **Auditability**: All state changes create permanent, queryable audit trail
- **Extensibility**: New features can subscribe to existing events without modification

### Implementation
- **Domain Events**: Generated by aggregate roots during business operations
- **Event Bus**: EventBridge adapter for publishing domain events
- **Event Handlers**: Lambda functions subscribing to specific event types
- **Event Store**: DynamoDB table for event sourcing and audit queries

### Trade-offs
- **Eventual Consistency**: Asynchronous processing requires careful ordering
- **Debugging Complexity**: Distributed event flows harder to trace
- **Cost**: EventBridge adds cost compared to direct function calls

---

## ADR-005: Lambda-lith Architecture Pattern

**Status**: Adopted
**Date**: 2024
**Context**: Balance between serverless benefits and cold start performance

### Decision
Single Lambda function handling multiple HTTP routes instead of per-function microservices.

### Rationale
- **Cold Start Optimization**: Shared connection pools and initialized resources
- **Cost Efficiency**: Lower total memory allocation and execution time
- **Operational Simplicity**: Single deployment unit, shared monitoring
- **Performance**: Reduced inter-service communication overhead

### Implementation
- **Main Lambda**: Handles all HTTP API routes through Chi router
- **Specialized Lambdas**: Only for fundamentally different workloads (WebSocket, batch processing)
- **Container Pattern**: DI container manages lifecycle across invocations
- **Connection Reuse**: Database and AWS service connections persist

### Trade-offs
- **Scaling Granularity**: Cannot scale individual endpoints independently
- **Blast Radius**: Issues in one route can affect all routes
- **Resource Allocation**: All routes share the same memory/CPU allocation

---

## ADR-006: Wire Dependency Injection

**Status**: Adopted
**Date**: 2024
**Context**: Need for compile-time dependency injection without reflection overhead

### Decision
Use Google Wire for compile-time dependency injection.

### Rationale
- **Cold Start Performance**: Zero reflection overhead during Lambda initialization
- **Compile-time Safety**: Dependency graph errors caught at build time
- **Explicit Dependencies**: Forces clear dependency declarations
- **Zero Runtime Cost**: All wiring happens at compile time

### Implementation
- **Provider Functions**: Create instances of services and dependencies
- **Wire Sets**: Group related providers for modularity
- **Build Tags**: Separate wire specification from generated code
- **Container Pattern**: Generated code assembled into lifecycle container

### Trade-offs
- **Code Generation**: Requires additional build step with `wire` command
- **Learning Curve**: Wire-specific patterns and debugging approaches
- **Build Complexity**: More complex build pipeline than manual DI

---

## ADR-007: Single-Table DynamoDB Design

**Status**: Adopted
**Date**: 2024
**Context**: Need for high-performance, cost-effective data access patterns

### Decision
Use DynamoDB single-table design with composite keys.

### Rationale
- **Performance**: Reduces cross-table joins and enables efficient batch operations
- **Cost Optimization**: Fewer read/write capacity units through data locality
- **Scalability**: Leverages DynamoDB's partition key distribution
- **Consistency**: Related entities stored together for transactional consistency

### Implementation
- **Key Pattern**: `PK = UserID`, `SK = EntityType#EntityID`
- **Data Isolation**: User data completely isolated by partition key
- **GSI Strategy**: Additional access patterns through Global Secondary Indexes
- **Batch Operations**: Related entities retrieved/updated in single operations

### Trade-offs
- **Complexity**: Single-table design requires careful access pattern analysis
- **Schema Evolution**: Changes require migration strategies
- **Debugging**: Less intuitive than normalized table structures

## Decision Status Legend

- **Proposed**: Decision is proposed but not yet approved
- **Adopted**: Decision is approved and implemented
- **Deprecated**: Decision is no longer recommended for new work
- **Superseded**: Decision has been replaced by a newer decision