// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

// AssignNodeToCategoryRequest defines model for AssignNodeToCategoryRequest.
type AssignNodeToCategoryRequest struct {
	NodeId string `json:"nodeId"`
}

// BulkDeleteRequest defines model for BulkDeleteRequest.
type BulkDeleteRequest struct {
	NodeIds []string `json:"nodeIds"`
}

// BulkDeleteResponse defines model for BulkDeleteResponse.
type BulkDeleteResponse struct {
	DeletedCount  *int      `json:"deletedCount,omitempty"`
	FailedNodeIds *[]string `json:"failedNodeIds,omitempty"`
	Message       *string   `json:"message,omitempty"`
}

// Category defines model for Category.
type Category struct {
	// AiGenerated Whether this category was created by AI
	AiGenerated *bool `json:"aiGenerated,omitempty"`

	// Color Hex color code for UI
	Color       *string   `json:"color,omitempty"`
	CreatedAt   time.Time `json:"createdAt"`
	Description *string   `json:"description,omitempty"`

	// Icon Icon identifier for UI
	Icon *string `json:"icon,omitempty"`
	Id   string  `json:"id"`

	// Level Hierarchy level: 0 = top level, 1 = sub, 2 = sub-sub
	Level int `json:"level"`

	// NoteCount Number of memories in this category
	NoteCount *int `json:"noteCount,omitempty"`

	// ParentId ID of parent category (null for root categories)
	ParentId  *string   `json:"parentId,omitempty"`
	Title     string    `json:"title"`
	UpdatedAt time.Time `json:"updatedAt"`
}

// CategoryActivity defines model for CategoryActivity.
type CategoryActivity struct {
	CategoryId   string `json:"categoryId"`
	CategoryName string `json:"categoryName"`
	MemoryCount  int    `json:"memoryCount"`

	// RecentAdds Memories added in the last 7 days
	RecentAdds int `json:"recentAdds"`
}

// CategoryConnection defines model for CategoryConnection.
type CategoryConnection struct {
	Category1Id   string `json:"category1Id"`
	Category1Name string `json:"category1Name"`
	Category2Id   string `json:"category2Id"`
	Category2Name string `json:"category2Name"`

	// Reason Explanation for the suggested connection
	Reason string `json:"reason"`

	// Strength Connection strength score
	Strength float32 `json:"strength"`
}

// CategoryGrowthTrend defines model for CategoryGrowthTrend.
type CategoryGrowthTrend struct {
	CategoryId   string    `json:"categoryId"`
	CategoryName string    `json:"categoryName"`
	Date         time.Time `json:"date"`
	MemoryCount  int       `json:"memoryCount"`
}

// CategoryInsights defines model for CategoryInsights.
type CategoryInsights struct {
	// CategoryGrowthTrends Growth patterns over time
	CategoryGrowthTrends *[]CategoryGrowthTrend `json:"categoryGrowthTrends,omitempty"`

	// KnowledgeGaps Identified areas for knowledge expansion
	KnowledgeGaps *[]KnowledgeGap `json:"knowledgeGaps,omitempty"`

	// MostActiveCategories Categories with the most recent activity
	MostActiveCategories *[]CategoryActivity `json:"mostActiveCategories,omitempty"`

	// SuggestedConnections Suggested relationships between categories
	SuggestedConnections *[]CategoryConnection `json:"suggestedConnections,omitempty"`
}

// CategorySuggestion defines model for CategorySuggestion.
type CategorySuggestion struct {
	// Confidence AI confidence score for this suggestion
	Confidence float32 `json:"confidence"`

	// Level Suggested hierarchy level
	Level int `json:"level"`

	// Name Suggested category name
	Name string `json:"name"`

	// ParentId ID of suggested parent category
	ParentId *string `json:"parentId,omitempty"`

	// Reason Explanation for why this category was suggested
	Reason string `json:"reason"`
}

// CreateCategoryRequest defines model for CreateCategoryRequest.
type CreateCategoryRequest struct {
	Description *string `json:"description,omitempty"`
	Title       string  `json:"title"`
}

// CreateNodeRequest defines model for CreateNodeRequest.
type CreateNodeRequest struct {
	Content string `json:"content"`

	// Tags User-defined tags for organizing and categorizing memories
	Tags *[]string `json:"tags,omitempty"`
}

// EdgeData defines model for EdgeData.
type EdgeData struct {
	Id     string `json:"id"`
	Source string `json:"source"`
	Target string `json:"target"`
}

// GraphDataResponse defines model for GraphDataResponse.
type GraphDataResponse struct {
	Elements *[]GraphDataResponse_Elements_Item `json:"elements,omitempty"`
}

// GraphDataResponse_Elements_Item defines model for GraphDataResponse.elements.Item.
type GraphDataResponse_Elements_Item struct {
	union json.RawMessage
}

// GraphEdge defines model for GraphEdge.
type GraphEdge struct {
	Data *EdgeData `json:"data,omitempty"`
}

// GraphNode defines model for GraphNode.
type GraphNode struct {
	Data *NodeData `json:"data,omitempty"`
}

// KnowledgeGap defines model for KnowledgeGap.
type KnowledgeGap struct {
	// Confidence Confidence in this gap identification
	Confidence float32 `json:"confidence"`

	// Reason Explanation for why this is a knowledge gap
	Reason string `json:"reason"`

	// SuggestedCategories Categories that could be created to fill this gap
	SuggestedCategories []string `json:"suggestedCategories"`

	// Topic Identified knowledge gap topic
	Topic string `json:"topic"`
}

// Node defines model for Node.
type Node struct {
	Content string `json:"content"`
	NodeId  string `json:"nodeId"`

	// Tags User-defined tags for organizing and categorizing memories
	Tags      *[]string `json:"tags,omitempty"`
	Timestamp time.Time `json:"timestamp"`
	Version   int       `json:"version"`
}

// NodeData defines model for NodeData.
type NodeData struct {
	Id    string `json:"id"`
	Label string `json:"label"`
}

// NodeDetails defines model for NodeDetails.
type NodeDetails struct {
	Content string    `json:"content"`
	Edges   *[]string `json:"edges,omitempty"`
	NodeId  string    `json:"nodeId"`

	// Tags User-defined tags for organizing and categorizing memories
	Tags      *[]string `json:"tags,omitempty"`
	Timestamp time.Time `json:"timestamp"`
	Version   int       `json:"version"`
}

// UpdateCategoryRequest defines model for UpdateCategoryRequest.
type UpdateCategoryRequest struct {
	Description *string `json:"description,omitempty"`
	Title       string  `json:"title"`
}

// UpdateNodeRequest defines model for UpdateNodeRequest.
type UpdateNodeRequest struct {
	Content string `json:"content"`

	// Tags User-defined tags for organizing and categorizing memories
	Tags *[]string `json:"tags,omitempty"`
}

// SuggestCategoriesJSONBody defines parameters for SuggestCategories.
type SuggestCategoriesJSONBody struct {
	// Content Content to analyze for category suggestions
	Content string `json:"content"`
}

// CreateCategoryJSONRequestBody defines body for CreateCategory for application/json ContentType.
type CreateCategoryJSONRequestBody = CreateCategoryRequest

// SuggestCategoriesJSONRequestBody defines body for SuggestCategories for application/json ContentType.
type SuggestCategoriesJSONRequestBody SuggestCategoriesJSONBody

// UpdateCategoryJSONRequestBody defines body for UpdateCategory for application/json ContentType.
type UpdateCategoryJSONRequestBody = UpdateCategoryRequest

// AssignNodeToCategoryJSONRequestBody defines body for AssignNodeToCategory for application/json ContentType.
type AssignNodeToCategoryJSONRequestBody = AssignNodeToCategoryRequest

// CreateNodeJSONRequestBody defines body for CreateNode for application/json ContentType.
type CreateNodeJSONRequestBody = CreateNodeRequest

// BulkDeleteNodesJSONRequestBody defines body for BulkDeleteNodes for application/json ContentType.
type BulkDeleteNodesJSONRequestBody = BulkDeleteRequest

// UpdateNodeJSONRequestBody defines body for UpdateNode for application/json ContentType.
type UpdateNodeJSONRequestBody = UpdateNodeRequest

// AsGraphNode returns the union data inside the GraphDataResponse_Elements_Item as a GraphNode
func (t GraphDataResponse_Elements_Item) AsGraphNode() (GraphNode, error) {
	var body GraphNode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGraphNode overwrites any union data inside the GraphDataResponse_Elements_Item as the provided GraphNode
func (t *GraphDataResponse_Elements_Item) FromGraphNode(v GraphNode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGraphNode performs a merge with any union data inside the GraphDataResponse_Elements_Item, using the provided GraphNode
func (t *GraphDataResponse_Elements_Item) MergeGraphNode(v GraphNode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGraphEdge returns the union data inside the GraphDataResponse_Elements_Item as a GraphEdge
func (t GraphDataResponse_Elements_Item) AsGraphEdge() (GraphEdge, error) {
	var body GraphEdge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGraphEdge overwrites any union data inside the GraphDataResponse_Elements_Item as the provided GraphEdge
func (t *GraphDataResponse_Elements_Item) FromGraphEdge(v GraphEdge) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGraphEdge performs a merge with any union data inside the GraphDataResponse_Elements_Item, using the provided GraphEdge
func (t *GraphDataResponse_Elements_Item) MergeGraphEdge(v GraphEdge) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GraphDataResponse_Elements_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GraphDataResponse_Elements_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all categories for the authenticated user
	// (GET /api/categories)
	ListCategories(w http.ResponseWriter, r *http.Request)
	// Create a new category
	// (POST /api/categories)
	CreateCategory(w http.ResponseWriter, r *http.Request)
	// Get hierarchical category tree
	// (GET /api/categories/hierarchy)
	GetCategoryHierarchy(w http.ResponseWriter, r *http.Request)
	// Get category usage insights and analytics
	// (GET /api/categories/insights)
	GetCategoryInsights(w http.ResponseWriter, r *http.Request)
	// Rebuild and optimize category structure
	// (POST /api/categories/rebuild)
	RebuildCategories(w http.ResponseWriter, r *http.Request)
	// Get AI-powered category suggestions for content
	// (POST /api/categories/suggest)
	SuggestCategories(w http.ResponseWriter, r *http.Request)
	// Delete a category and all its memory associations
	// (DELETE /api/categories/{categoryId})
	DeleteCategory(w http.ResponseWriter, r *http.Request, categoryId string)
	// Get detailed information for a single category
	// (GET /api/categories/{categoryId})
	GetCategory(w http.ResponseWriter, r *http.Request, categoryId string)
	// Update a category's details
	// (PUT /api/categories/{categoryId})
	UpdateCategory(w http.ResponseWriter, r *http.Request, categoryId string)
	// Get all nodes in a specific category
	// (GET /api/categories/{categoryId}/nodes)
	GetNodesInCategory(w http.ResponseWriter, r *http.Request, categoryId string)
	// Assign a node to a category
	// (POST /api/categories/{categoryId}/nodes)
	AssignNodeToCategory(w http.ResponseWriter, r *http.Request, categoryId string)
	// Remove a node from a category
	// (DELETE /api/categories/{categoryId}/nodes/{nodeId})
	RemoveNodeFromCategory(w http.ResponseWriter, r *http.Request, categoryId string, nodeId string)
	// Get complete graph data optimized for visualization libraries
	// (GET /api/graph-data)
	GetGraphData(w http.ResponseWriter, r *http.Request)
	// List all memory nodes for the authenticated user
	// (GET /api/nodes)
	ListNodes(w http.ResponseWriter, r *http.Request)
	// Create a new memory node with automatic keyword extraction
	// (POST /api/nodes)
	CreateNode(w http.ResponseWriter, r *http.Request)
	// Delete multiple memory nodes efficiently in a single operation
	// (POST /api/nodes/bulk-delete)
	BulkDeleteNodes(w http.ResponseWriter, r *http.Request)
	// Delete a memory node and clean up all connections
	// (DELETE /api/nodes/{nodeId})
	DeleteNode(w http.ResponseWriter, r *http.Request, nodeId string)
	// Get detailed information for a single memory node
	// (GET /api/nodes/{nodeId})
	GetNode(w http.ResponseWriter, r *http.Request, nodeId string)
	// Update a memory node's content with automatic reconnection
	// (PUT /api/nodes/{nodeId})
	UpdateNode(w http.ResponseWriter, r *http.Request, nodeId string)
	// Get all categories assigned to a node
	// (GET /api/nodes/{nodeId}/categories)
	GetNodeCategories(w http.ResponseWriter, r *http.Request, nodeId string)
	// Auto-categorize a node using AI
	// (POST /api/nodes/{nodeId}/categories)
	CategorizeNode(w http.ResponseWriter, r *http.Request, nodeId string)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List all categories for the authenticated user
// (GET /api/categories)
func (_ Unimplemented) ListCategories(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new category
// (POST /api/categories)
func (_ Unimplemented) CreateCategory(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get hierarchical category tree
// (GET /api/categories/hierarchy)
func (_ Unimplemented) GetCategoryHierarchy(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get category usage insights and analytics
// (GET /api/categories/insights)
func (_ Unimplemented) GetCategoryInsights(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Rebuild and optimize category structure
// (POST /api/categories/rebuild)
func (_ Unimplemented) RebuildCategories(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get AI-powered category suggestions for content
// (POST /api/categories/suggest)
func (_ Unimplemented) SuggestCategories(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a category and all its memory associations
// (DELETE /api/categories/{categoryId})
func (_ Unimplemented) DeleteCategory(w http.ResponseWriter, r *http.Request, categoryId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get detailed information for a single category
// (GET /api/categories/{categoryId})
func (_ Unimplemented) GetCategory(w http.ResponseWriter, r *http.Request, categoryId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a category's details
// (PUT /api/categories/{categoryId})
func (_ Unimplemented) UpdateCategory(w http.ResponseWriter, r *http.Request, categoryId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get all nodes in a specific category
// (GET /api/categories/{categoryId}/nodes)
func (_ Unimplemented) GetNodesInCategory(w http.ResponseWriter, r *http.Request, categoryId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Assign a node to a category
// (POST /api/categories/{categoryId}/nodes)
func (_ Unimplemented) AssignNodeToCategory(w http.ResponseWriter, r *http.Request, categoryId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Remove a node from a category
// (DELETE /api/categories/{categoryId}/nodes/{nodeId})
func (_ Unimplemented) RemoveNodeFromCategory(w http.ResponseWriter, r *http.Request, categoryId string, nodeId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get complete graph data optimized for visualization libraries
// (GET /api/graph-data)
func (_ Unimplemented) GetGraphData(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all memory nodes for the authenticated user
// (GET /api/nodes)
func (_ Unimplemented) ListNodes(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a new memory node with automatic keyword extraction
// (POST /api/nodes)
func (_ Unimplemented) CreateNode(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete multiple memory nodes efficiently in a single operation
// (POST /api/nodes/bulk-delete)
func (_ Unimplemented) BulkDeleteNodes(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a memory node and clean up all connections
// (DELETE /api/nodes/{nodeId})
func (_ Unimplemented) DeleteNode(w http.ResponseWriter, r *http.Request, nodeId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get detailed information for a single memory node
// (GET /api/nodes/{nodeId})
func (_ Unimplemented) GetNode(w http.ResponseWriter, r *http.Request, nodeId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a memory node's content with automatic reconnection
// (PUT /api/nodes/{nodeId})
func (_ Unimplemented) UpdateNode(w http.ResponseWriter, r *http.Request, nodeId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get all categories assigned to a node
// (GET /api/nodes/{nodeId}/categories)
func (_ Unimplemented) GetNodeCategories(w http.ResponseWriter, r *http.Request, nodeId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Auto-categorize a node using AI
// (POST /api/nodes/{nodeId}/categories)
func (_ Unimplemented) CategorizeNode(w http.ResponseWriter, r *http.Request, nodeId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListCategories operation middleware
func (siw *ServerInterfaceWrapper) ListCategories(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListCategories(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateCategory operation middleware
func (siw *ServerInterfaceWrapper) CreateCategory(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCategory(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCategoryHierarchy operation middleware
func (siw *ServerInterfaceWrapper) GetCategoryHierarchy(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCategoryHierarchy(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCategoryInsights operation middleware
func (siw *ServerInterfaceWrapper) GetCategoryInsights(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCategoryInsights(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RebuildCategories operation middleware
func (siw *ServerInterfaceWrapper) RebuildCategories(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RebuildCategories(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SuggestCategories operation middleware
func (siw *ServerInterfaceWrapper) SuggestCategories(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SuggestCategories(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteCategory operation middleware
func (siw *ServerInterfaceWrapper) DeleteCategory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "categoryId" -------------
	var categoryId string

	err = runtime.BindStyledParameterWithOptions("simple", "categoryId", chi.URLParam(r, "categoryId"), &categoryId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "categoryId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCategory(w, r, categoryId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetCategory operation middleware
func (siw *ServerInterfaceWrapper) GetCategory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "categoryId" -------------
	var categoryId string

	err = runtime.BindStyledParameterWithOptions("simple", "categoryId", chi.URLParam(r, "categoryId"), &categoryId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "categoryId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCategory(w, r, categoryId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateCategory operation middleware
func (siw *ServerInterfaceWrapper) UpdateCategory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "categoryId" -------------
	var categoryId string

	err = runtime.BindStyledParameterWithOptions("simple", "categoryId", chi.URLParam(r, "categoryId"), &categoryId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "categoryId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateCategory(w, r, categoryId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNodesInCategory operation middleware
func (siw *ServerInterfaceWrapper) GetNodesInCategory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "categoryId" -------------
	var categoryId string

	err = runtime.BindStyledParameterWithOptions("simple", "categoryId", chi.URLParam(r, "categoryId"), &categoryId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "categoryId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodesInCategory(w, r, categoryId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AssignNodeToCategory operation middleware
func (siw *ServerInterfaceWrapper) AssignNodeToCategory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "categoryId" -------------
	var categoryId string

	err = runtime.BindStyledParameterWithOptions("simple", "categoryId", chi.URLParam(r, "categoryId"), &categoryId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "categoryId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AssignNodeToCategory(w, r, categoryId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RemoveNodeFromCategory operation middleware
func (siw *ServerInterfaceWrapper) RemoveNodeFromCategory(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "categoryId" -------------
	var categoryId string

	err = runtime.BindStyledParameterWithOptions("simple", "categoryId", chi.URLParam(r, "categoryId"), &categoryId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "categoryId", Err: err})
		return
	}

	// ------------- Path parameter "nodeId" -------------
	var nodeId string

	err = runtime.BindStyledParameterWithOptions("simple", "nodeId", chi.URLParam(r, "nodeId"), &nodeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nodeId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RemoveNodeFromCategory(w, r, categoryId, nodeId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetGraphData operation middleware
func (siw *ServerInterfaceWrapper) GetGraphData(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGraphData(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListNodes operation middleware
func (siw *ServerInterfaceWrapper) ListNodes(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListNodes(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateNode operation middleware
func (siw *ServerInterfaceWrapper) CreateNode(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateNode(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// BulkDeleteNodes operation middleware
func (siw *ServerInterfaceWrapper) BulkDeleteNodes(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BulkDeleteNodes(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteNode operation middleware
func (siw *ServerInterfaceWrapper) DeleteNode(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "nodeId" -------------
	var nodeId string

	err = runtime.BindStyledParameterWithOptions("simple", "nodeId", chi.URLParam(r, "nodeId"), &nodeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nodeId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteNode(w, r, nodeId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNode operation middleware
func (siw *ServerInterfaceWrapper) GetNode(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "nodeId" -------------
	var nodeId string

	err = runtime.BindStyledParameterWithOptions("simple", "nodeId", chi.URLParam(r, "nodeId"), &nodeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nodeId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNode(w, r, nodeId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateNode operation middleware
func (siw *ServerInterfaceWrapper) UpdateNode(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "nodeId" -------------
	var nodeId string

	err = runtime.BindStyledParameterWithOptions("simple", "nodeId", chi.URLParam(r, "nodeId"), &nodeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nodeId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateNode(w, r, nodeId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetNodeCategories operation middleware
func (siw *ServerInterfaceWrapper) GetNodeCategories(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "nodeId" -------------
	var nodeId string

	err = runtime.BindStyledParameterWithOptions("simple", "nodeId", chi.URLParam(r, "nodeId"), &nodeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nodeId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetNodeCategories(w, r, nodeId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CategorizeNode operation middleware
func (siw *ServerInterfaceWrapper) CategorizeNode(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "nodeId" -------------
	var nodeId string

	err = runtime.BindStyledParameterWithOptions("simple", "nodeId", chi.URLParam(r, "nodeId"), &nodeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "nodeId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CategorizeNode(w, r, nodeId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/categories", wrapper.ListCategories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/categories", wrapper.CreateCategory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/categories/hierarchy", wrapper.GetCategoryHierarchy)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/categories/insights", wrapper.GetCategoryInsights)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/categories/rebuild", wrapper.RebuildCategories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/categories/suggest", wrapper.SuggestCategories)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/categories/{categoryId}", wrapper.DeleteCategory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/categories/{categoryId}", wrapper.GetCategory)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/categories/{categoryId}", wrapper.UpdateCategory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/categories/{categoryId}/nodes", wrapper.GetNodesInCategory)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/categories/{categoryId}/nodes", wrapper.AssignNodeToCategory)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/categories/{categoryId}/nodes/{nodeId}", wrapper.RemoveNodeFromCategory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/graph-data", wrapper.GetGraphData)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/nodes", wrapper.ListNodes)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/nodes", wrapper.CreateNode)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/nodes/bulk-delete", wrapper.BulkDeleteNodes)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/api/nodes/{nodeId}", wrapper.DeleteNode)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/nodes/{nodeId}", wrapper.GetNode)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/api/nodes/{nodeId}", wrapper.UpdateNode)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/api/nodes/{nodeId}/categories", wrapper.GetNodeCategories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/api/nodes/{nodeId}/categories", wrapper.CategorizeNode)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
