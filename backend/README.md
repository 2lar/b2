# Brain2 Backend

This repository contains the backend services for the Brain2 application.

## Project Structure

The project is structured to follow Clean Architecture principles:

-   `cmd/`: Contains the main entry points for the application (e.g., `main.go` for the Lambda handler).
-   `internal/`: Private application code, not intended for external consumption.
    -   `app/`: Application-level configurations and utilities.
    -   `config/`: Application configuration loading.
    -   `di/`: Dependency Injection setup using Wire.
    -   `domain/`: Core business entities and rules (agnostic of frameworks/databases).
    -   `handlers/`: HTTP handlers responsible for processing requests and returning responses.
    -   `repository/`: Interfaces defining data persistence operations.
    -   `service/`: Business logic and application-specific rules, orchestrating domain and repository interactions.
-   `infrastructure/`: Concrete implementations of interfaces defined in `internal/`, typically external concerns like databases or external APIs.
    -   `dynamodb/`: DynamoDB specific repository implementations.
-   `pkg/`: Public utility packages that can be used across different parts of the application or by other services.
    -   `api/`: API response structures and helper functions.
    -   `errors/`: Custom error types.

## Quick Command Reference

For a comprehensive list of all commands, see [ðŸ“š Command Master List](../docs/command-masterlist.md)

### Most Common Commands
```bash
# Install dependencies
go mod tidy

# Run tests
go test ./...

# Build for Lambda
./build.sh

# Quick build (no tests)
./test_build.sh

# Generate Wire dependencies
cd internal/di && wire

# Run locally
go run cmd/main/main.go

# Format code
go fmt ./...

# Run linter
golangci-lint run
```

## Getting Started

### Prerequisites

-   Go (version 1.22 or higher)
-   AWS CLI configured with appropriate credentials
-   Docker (for local DynamoDB development, if applicable)

### Local Development

1.  **Install Dependencies:**
    ```bash
    go mod tidy
    ```

2.  **Set up Environment Variables:**
    Create a `.env` file in the `backend/` directory (or set them directly in your shell):
    ```
    TABLE_NAME=your-dynamodb-table-name
    INDEX_NAME=your-dynamodb-gsi-name
    ```
    (For local development, you might use a local DynamoDB instance and configure the AWS SDK accordingly.)

3.  **Build the Application:**
    ```bash
    go build -o bin/main cmd/main/main.go
    ```

4.  **Run Locally (e.g., with a local API Gateway emulator or directly):**
    If running as a Lambda function locally, you might use `sam local start-api` or similar tools.

## Dependency Injection with Wire

This project uses [Wire](https://github.com/google/wire) for compile-time dependency injection. Wire generates code that connects components, ensuring a clean and maintainable dependency graph.

### Why Wire?

Wire helps enforce Clean Architecture principles by:
-   **Automating Dependency Graph:** You define how to provide dependencies, and Wire generates the boilerplate code to connect them.
-   **Compile-Time Safety:** Errors in the dependency graph are caught at compile time, not runtime.
-   **Reduced Boilerplate:** Eliminates manual dependency wiring, especially in large applications.
-   **Enforcing Layering:** Encourages explicit dependency declarations, making it harder to violate architectural rules.

### Installation

To install Wire, run:

```bash
go install github.com/google/wire/cmd/wire@latest
```

### Generating Dependencies

After making changes to your dependency providers (functions that create instances of your components) in `internal/di/wire.go`, you need to run Wire to generate the actual dependency injection code.

1.  Navigate to the `di` directory:
    ```bash
    cd backend/internal/di
    ```

2.  Run the `wire` command:
    ```bash
    wire
    ```
    This command will generate or update `wire_gen.go` in the same directory. This file contains the `InitializeAPI` function (and other generated providers) that constructs the entire application's dependency graph.

    **Important:**
    -   `wire.go` contains the `//go:build wireinject` build tag. This tells the Go compiler to *only* compile this file when the `wire` command is run.
    -   `wire_gen.go` contains the `//go:build !wireinject` build tag. This tells the Go compiler to *exclude* `wire.go` and *include* `wire_gen.go` during normal `go build` operations. This prevents redeclaration errors.

### Integration with `main.go`

The `cmd/main/main.go` file is the entry point of the application. It uses the `InitializeAPI` function generated by Wire to get a fully constructed HTTP router (`*chi.Mux`).

```go
package main

import (
	"context"
	"log"

	"brain2-backend/internal/di"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	chiadapter "github.com/awslabs/aws-lambda-go-api-proxy/chi"
)

var chiLambda *chiadapter.ChiLambdaV2

func init() {
	// InitializeAPI is generated by Wire and constructs the entire dependency graph.
	router, err := di.InitializeAPI()
	if err != nil {
		log.Fatalf("Failed to initialize API: %v", err)
	}
	// Wrap the chi router with the Lambda adapter
	chiLambda = chiadapter.NewV2(router)
	log.Println("Service initialized successfully with Wire DI")
}

func main() {
	// Start the Lambda handler
	lambda.Start(func(ctx context.Context, req events.APIGatewayV2HTTPRequest) (events.APIGatewayV2HTTPResponse, error) {
		return chiLambda.ProxyWithContextV2(ctx, req)
	})
}
```

By following these steps, you can effectively manage your backend's dependencies using Wire, ensuring a clean and maintainable architecture.
