// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

// Injectors from wire.go:

// InitializeContainer wires together all dependencies using Wire.
// This function signature tells Wire what to generate by analyzing SuperSet.
//
// Wire Process:
//  1. Analyzes all provider functions in SuperSet
//  2. Builds dependency graph ensuring proper initialization order
//  3. Generates wire_gen.go with concrete implementation
//  4. Catches circular dependencies and missing providers at compile time
//
// The generated code is equivalent to manually calling all provider functions
// in the correct order, but without the maintenance burden.
func InitializeContainer() (*Container, error) {
	config, err := provideConfig()
	if err != nil {
		return nil, err
	}
	logger, err := provideLogger(config)
	if err != nil {
		return nil, err
	}
	context := provideContext()
	awsConfig, err := provideAWSConfig(context, config)
	if err != nil {
		return nil, err
	}
	client := provideDynamoDBClient(awsConfig, config)
	eventbridgeClient := provideEventBridgeClient(awsConfig)
	repositoryFactory := provideRepositoryFactory(config)
	cache := provideCache(config, logger)
	collector := provideMetricsCollector(config, logger)
	nodeRepository := provideNodeRepository(client, config, logger, repositoryFactory, cache, collector)
	edgeRepository := provideEdgeRepository(client, config, logger, cache, collector)
	categoryRepository := provideCategoryRepository(client, config, logger, repositoryFactory, cache, collector)
	keywordRepository := provideKeywordRepository(client, config)
	transactionalRepository := provideTransactionalRepository(client, config, logger)
	graphRepository := provideGraphRepository(client, config, logger)
	repository := provideRepository(client, config, logger)
	idempotencyStore := provideIdempotencyStore(client, config)
	store := provideStore(client, config, logger)
	tracerProvider, err := provideTracerProvider(config)
	if err != nil {
		return nil, err
	}
	eventBus := provideEventBus(config, eventbridgeClient, logger)
	eventStore := provideEventStore(client, config)
	unitOfWorkFactory := provideUnitOfWorkFactory(client, config, eventBus, eventStore, logger)
	connectionAnalyzer := provideConnectionAnalyzer(config)
	nodeService := provideNodeService(nodeRepository, edgeRepository, unitOfWorkFactory, eventBus, connectionAnalyzer, idempotencyStore)
	unitOfWork := provideUnitOfWork(nodeRepository, edgeRepository, keywordRepository, transactionalRepository)
	categoryService := provideCategoryAppService(categoryRepository, unitOfWork, eventBus)
	cleanupService := provideCleanupService(nodeRepository, edgeRepository, idempotencyStore, unitOfWorkFactory)
	nodeQueryService := provideNodeQueryService(nodeRepository, edgeRepository, graphRepository, cache)
	categoryQueryService := provideCategoryQueryService(categoryRepository, nodeRepository, cache, logger)
	queriesCache := provideCacheAdapter(cache)
	graphQueryService := provideGraphQueryService(store, logger, queriesCache)
	coldStartTracker := ProvideColdStartTracker()
	memoryHandler := provideMemoryHandler(nodeService, nodeQueryService, graphQueryService, eventbridgeClient, coldStartTracker)
	categoryHandler := provideCategoryHandler(categoryService, categoryQueryService)
	healthHandler := provideHealthHandler()
	mux := provideRouter(memoryHandler, categoryHandler, healthHandler, config)
	container := provideContainer(config, logger, client, eventbridgeClient, nodeRepository, edgeRepository, categoryRepository, keywordRepository, transactionalRepository, graphRepository, repository, idempotencyStore, store, cache, collector, tracerProvider, nodeService, categoryService, cleanupService, nodeQueryService, categoryQueryService, graphQueryService, connectionAnalyzer, eventBus, unitOfWork, memoryHandler, categoryHandler, healthHandler, mux, repositoryFactory, coldStartTracker)
	return container, nil
}
