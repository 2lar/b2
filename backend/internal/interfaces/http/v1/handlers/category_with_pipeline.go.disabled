/*
ARCHITECTURAL REFERENCE FILE - KEEP BUT DISABLED

This file demonstrates an advanced middleware pipeline architecture that follows SOLID principles
and implements the Open/Closed Principle for HTTP handlers. It showcases enterprise-grade patterns
that could be valuable for future development.

WHY THIS FILE IS KEPT:
- Demonstrates clean middleware pipeline pattern using Chain of Responsibility
- Shows proper CQRS handler separation (queries vs commands with different middleware stacks)
- Implements cross-cutting concerns abstraction (auth, logging, validation, etc.)
- Provides a scalable approach for handling complex middleware requirements
- Follows enterprise design patterns that could be needed as the system grows

CURRENT STATUS: DISABLED
This file is currently disabled due to type compatibility issues between DTO packages.
It should remain disabled until:
1. DTO type conflicts are resolved between application/dto and interfaces/http/v1/dto packages
2. The middleware pipeline pattern is actually needed (when current handlers become unwieldy)
3. Complex cross-cutting concerns need to be added (rate limiting, caching, circuit breakers)

TO RE-ENABLE:
1. Fix type compatibility between CategoryView types in different packages
2. Rename file to remove .disabled extension
3. Update imports and test thoroughly
4. Consider migrating other handlers to use the same pattern for consistency

ARCHITECTURAL BENEFITS WHEN ENABLED:
- Handler methods focus purely on business logic
- Middleware components are reusable and testable in isolation
- Easy to add/remove/reorder cross-cutting concerns without touching business logic
- Consistent request processing pipeline across all handlers
- Better separation of concerns and adherence to Single Responsibility Principle
*/

// Package handlers demonstrates the use of middleware pipeline following Open/Closed Principle.
package handlers

import (
	"fmt"
	"net/http"

	"brain2-backend/internal/application/commands"
	"brain2-backend/internal/application/queries"
	"brain2-backend/internal/application/services"
	"brain2-backend/internal/interfaces/http/v1/dto"
	"brain2-backend/internal/interfaces/http/v1/middleware"
	"brain2-backend/internal/interfaces/http/v1/validation"
	"brain2-backend/pkg/api"

	"github.com/go-chi/chi/v5"
	"go.uber.org/zap"
)

// CategoryHandlerWithPipeline demonstrates clean handler design using middleware pipeline.
// This handler follows the Open/Closed Principle by using composable middleware
// instead of embedding cross-cutting concerns directly in handler methods.
type CategoryHandlerWithPipeline struct {
	// Core CQRS services
	categoryService      *services.CategoryService
	categoryQueryService *queries.CategoryQueryService

	// Focused components
	validator *validation.CategoryValidator
	converter *dto.CategoryConverter
	logger    *zap.Logger

	// Middleware pipelines for different operation types
	queryPipeline   *middleware.Pipeline
	commandPipeline *middleware.Pipeline
}

// NewCategoryHandlerWithPipeline creates a new category handler with middleware pipelines.
func NewCategoryHandlerWithPipeline(
	categoryService *services.CategoryService,
	categoryQueryService *queries.CategoryQueryService,
	logger *zap.Logger,
) *CategoryHandlerWithPipeline {
	handler := &CategoryHandlerWithPipeline{
		categoryService:      categoryService,
		categoryQueryService: categoryQueryService,
		validator:            validation.NewCategoryValidator(),
		converter:            dto.NewCategoryConverter(),
		logger:               logger,
	}

	// Build specialized pipelines for different operation types
	handler.buildPipelines()

	return handler
}

// buildPipelines constructs middleware pipelines for different operation types.
// This demonstrates the Builder Pattern for creating complex middleware chains.
func (h *CategoryHandlerWithPipeline) buildPipelines() {
	// Query pipeline: Error Recovery -> Logging -> Auth -> Service Check
	h.queryPipeline = middleware.BuildCQRSQueryMiddleware(
		h.logger,
		func() bool { return h.categoryQueryService != nil },
	)

	// Command pipeline: Error Recovery -> Logging -> Auth -> Service Check -> Validation
	h.commandPipeline = middleware.BuildCQRSCommandMiddleware(
		h.logger,
		func() bool { return h.categoryService != nil },
		nil, // Validation is handled per-endpoint since it varies
	)
}

// ============================================================================
// QUERY HANDLERS (READ OPERATIONS)
// ============================================================================

// ListCategories handles GET /api/categories using query pipeline.
func (h *CategoryHandlerWithPipeline) ListCategories(w http.ResponseWriter, r *http.Request) {
	handler := h.queryPipeline.Build(h.listCategoriesCore)
	handler(w, r)
}

// listCategoriesCore contains the core business logic without cross-cutting concerns.
func (h *CategoryHandlerWithPipeline) listCategoriesCore(w http.ResponseWriter, r *http.Request) {
	userID, ok := middleware.GetUserIDFromContext(r.Context())
	if !ok {
		api.Error(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	// Create query using CQRS pattern
	listQuery, err := queries.NewListCategoriesQuery(userID)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	listQuery.WithNodeCounts()

	// Execute query
	result, err := h.categoryQueryService.ListCategories(r.Context(), listQuery)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	// Convert and respond
	response := h.converter.FromCategoryViews(result.Categories)
	api.Success(w, http.StatusOK, response)
}

// GetCategory handles GET /api/categories/{categoryId} using query pipeline.
func (h *CategoryHandlerWithPipeline) GetCategory(w http.ResponseWriter, r *http.Request) {
	handler := h.queryPipeline.Build(h.getCategoryCore)
	handler(w, r)
}

// getCategoryCore contains the core business logic for getting a single category.
func (h *CategoryHandlerWithPipeline) getCategoryCore(w http.ResponseWriter, r *http.Request) {
	userID, ok := middleware.GetUserIDFromContext(r.Context())
	if !ok {
		api.Error(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	categoryID := chi.URLParam(r, "categoryId")

	// Create and execute query
	categoryQuery, err := queries.NewGetCategoryQuery(userID, categoryID)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	result, err := h.categoryQueryService.GetCategory(r.Context(), categoryQuery)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	// Convert and respond
	response := h.converter.FromCategoryView(result.Category)
	api.Success(w, http.StatusOK, response)
}

// ============================================================================
// COMMAND HANDLERS (WRITE OPERATIONS)
// ============================================================================

// CreateCategory handles POST /api/categories using command pipeline with validation.
func (h *CategoryHandlerWithPipeline) CreateCategory(w http.ResponseWriter, r *http.Request) {
	// Build pipeline with specific validation for create operations
	pipeline := middleware.NewPipelineBuilder(h.logger).
		WithErrorRecovery().
		WithLogging().
		WithAuthentication().
		WithServiceAvailability("CategoryService", func() bool { return h.categoryService != nil }).
		WithValidation(h.validateCreateCategoryRequest).
		Build()

	handler := pipeline.Build(h.createCategoryCore)
	handler(w, r)
}

// validateCreateCategoryRequest validates create category requests.
func (h *CategoryHandlerWithPipeline) validateCreateCategoryRequest(r *http.Request) error {
	_, validationResult := h.validator.ValidateCreateCategoryRequest(r)
	if !validationResult.IsValid {
		return fmt.Errorf(h.validator.FormatValidationErrors(validationResult.Errors))
	}
	return nil
}

// createCategoryCore contains the core business logic for creating categories.
func (h *CategoryHandlerWithPipeline) createCategoryCore(w http.ResponseWriter, r *http.Request) {
	userID, ok := middleware.GetUserIDFromContext(r.Context())
	if !ok {
		api.Error(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	// Re-validate to get the parsed request (validation middleware only validates)
	req, _ := h.validator.ValidateCreateCategoryRequest(r)

	// Create and execute command
	cmd, err := commands.NewCreateCategoryCommand(userID, req.Title, req.Description)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	result, err := h.categoryService.CreateCategory(r.Context(), cmd)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	// Convert and respond
	response := h.converter.FromCategoryView(result.Category)
	api.Success(w, http.StatusCreated, response)
}

// UpdateCategory handles PUT /api/categories/{categoryId} using command pipeline.
func (h *CategoryHandlerWithPipeline) UpdateCategory(w http.ResponseWriter, r *http.Request) {
	// Build pipeline with specific validation for update operations
	pipeline := middleware.NewPipelineBuilder(h.logger).
		WithErrorRecovery().
		WithLogging().
		WithAuthentication().
		WithServiceAvailability("CategoryService", func() bool { return h.categoryService != nil }).
		WithValidation(h.validateUpdateCategoryRequest).
		Build()

	handler := pipeline.Build(h.updateCategoryCore)
	handler(w, r)
}

// validateUpdateCategoryRequest validates update category requests.
func (h *CategoryHandlerWithPipeline) validateUpdateCategoryRequest(r *http.Request) error {
	_, validationResult := h.validator.ValidateUpdateCategoryRequest(r)
	if !validationResult.IsValid {
		return fmt.Errorf(h.validator.FormatValidationErrors(validationResult.Errors))
	}
	return nil
}

// updateCategoryCore contains the core business logic for updating categories.
func (h *CategoryHandlerWithPipeline) updateCategoryCore(w http.ResponseWriter, r *http.Request) {
	userID, ok := middleware.GetUserIDFromContext(r.Context())
	if !ok {
		api.Error(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	categoryID := chi.URLParam(r, "categoryId")
	req, _ := h.validator.ValidateUpdateCategoryRequest(r)

	// Create and execute command
	cmd, err := commands.NewUpdateCategoryCommand(userID, categoryID)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	cmd.WithTitle(req.Title).WithDescription(req.Description)

	result, err := h.categoryService.UpdateCategory(r.Context(), cmd)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	api.Success(w, http.StatusOK, map[string]interface{}{
		"message":    "Category updated successfully",
		"categoryId": result.Category.ID,
	})
}

// DeleteCategory handles DELETE /api/categories/{categoryId} using command pipeline.
func (h *CategoryHandlerWithPipeline) DeleteCategory(w http.ResponseWriter, r *http.Request) {
	handler := h.commandPipeline.Build(h.deleteCategoryCore)
	handler(w, r)
}

// deleteCategoryCore contains the core business logic for deleting categories.
func (h *CategoryHandlerWithPipeline) deleteCategoryCore(w http.ResponseWriter, r *http.Request) {
	userID, ok := middleware.GetUserIDFromContext(r.Context())
	if !ok {
		api.Error(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	categoryID := chi.URLParam(r, "categoryId")

	// Create and execute command
	cmd, err := commands.NewDeleteCategoryCommand(userID, categoryID)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	_, err = h.categoryService.DeleteCategory(r.Context(), cmd)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// ============================================================================
// DEMONSTRATION OF PIPELINE EXTENSIBILITY
// ============================================================================

// AddCustomMiddleware demonstrates how to extend the pipeline without modifying existing code.
// This method follows the Open/Closed Principle by allowing extension through configuration.
func (h *CategoryHandlerWithPipeline) AddCustomMiddleware(name string, priority int, fn middleware.MiddlewareFunc) {
	h.queryPipeline.AddFunc(name, priority, fn)
	h.commandPipeline.AddFunc(name, priority, fn)
}

// CreateSpecializedPipeline demonstrates creating custom pipelines for specific use cases.
func (h *CategoryHandlerWithPipeline) CreateSpecializedPipeline() *middleware.Pipeline {
	return middleware.NewPipelineBuilder(h.logger).
		WithErrorRecovery().
		WithLogging().
		WithAuthentication().
		WithCustomFunc("RateLimiting", 12, h.rateLimitMiddleware).
		WithCustomFunc("Caching", 25, h.cachingMiddleware).
		Build()
}

// rateLimitMiddleware is an example of a custom middleware function.
func (h *CategoryHandlerWithPipeline) rateLimitMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Rate limiting logic here
		next(w, r)
	}
}

// cachingMiddleware is another example of a custom middleware function.
func (h *CategoryHandlerWithPipeline) cachingMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Caching logic here
		next(w, r)
	}
}
