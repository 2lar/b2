// Package handlers demonstrates the use of middleware pipeline following Open/Closed Principle.
package handlers

import (
	"fmt"
	"net/http"

	"brain2-backend/internal/application/commands"
	"brain2-backend/internal/application/queries"
	"brain2-backend/internal/application/services"
	"brain2-backend/internal/interfaces/http/v1/dto"
	"brain2-backend/internal/interfaces/http/v1/middleware"
	"brain2-backend/internal/interfaces/http/v1/validation"
	"brain2-backend/pkg/api"

	"github.com/go-chi/chi/v5"
	"go.uber.org/zap"
)

// CategoryHandlerWithPipeline demonstrates clean handler design using middleware pipeline.
// This handler follows the Open/Closed Principle by using composable middleware
// instead of embedding cross-cutting concerns directly in handler methods.
type CategoryHandlerWithPipeline struct {
	// Core CQRS services
	categoryService      *services.CategoryService
	categoryQueryService *queries.CategoryQueryService

	// Focused components
	validator *validation.CategoryValidator
	converter *dto.CategoryConverter
	logger    *zap.Logger

	// Middleware pipelines for different operation types
	queryPipeline   *middleware.Pipeline
	commandPipeline *middleware.Pipeline
}

// NewCategoryHandlerWithPipeline creates a new category handler with middleware pipelines.
func NewCategoryHandlerWithPipeline(
	categoryService *services.CategoryService,
	categoryQueryService *queries.CategoryQueryService,
	logger *zap.Logger,
) *CategoryHandlerWithPipeline {
	handler := &CategoryHandlerWithPipeline{
		categoryService:      categoryService,
		categoryQueryService: categoryQueryService,
		validator:            validation.NewCategoryValidator(),
		converter:            dto.NewCategoryConverter(),
		logger:               logger,
	}

	// Build specialized pipelines for different operation types
	handler.buildPipelines()

	return handler
}

// buildPipelines constructs middleware pipelines for different operation types.
// This demonstrates the Builder Pattern for creating complex middleware chains.
func (h *CategoryHandlerWithPipeline) buildPipelines() {
	// Query pipeline: Error Recovery -> Logging -> Auth -> Service Check
	h.queryPipeline = middleware.BuildCQRSQueryMiddleware(
		h.logger,
		func() bool { return h.categoryQueryService != nil },
	)

	// Command pipeline: Error Recovery -> Logging -> Auth -> Service Check -> Validation
	h.commandPipeline = middleware.BuildCQRSCommandMiddleware(
		h.logger,
		func() bool { return h.categoryService != nil },
		nil, // Validation is handled per-endpoint since it varies
	)
}

// ============================================================================
// QUERY HANDLERS (READ OPERATIONS)
// ============================================================================

// ListCategories handles GET /api/categories using query pipeline.
func (h *CategoryHandlerWithPipeline) ListCategories(w http.ResponseWriter, r *http.Request) {
	handler := h.queryPipeline.Build(h.listCategoriesCore)
	handler(w, r)
}

// listCategoriesCore contains the core business logic without cross-cutting concerns.
func (h *CategoryHandlerWithPipeline) listCategoriesCore(w http.ResponseWriter, r *http.Request) {
	userID, ok := middleware.GetUserIDFromContext(r.Context())
	if !ok {
		api.Error(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	// Create query using CQRS pattern
	listQuery, err := queries.NewListCategoriesQuery(userID)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	listQuery.WithNodeCounts()

	// Execute query
	result, err := h.categoryQueryService.ListCategories(r.Context(), listQuery)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	// Convert and respond
	response := h.converter.FromCategoryViews(result.Categories)
	api.Success(w, http.StatusOK, response)
}

// GetCategory handles GET /api/categories/{categoryId} using query pipeline.
func (h *CategoryHandlerWithPipeline) GetCategory(w http.ResponseWriter, r *http.Request) {
	handler := h.queryPipeline.Build(h.getCategoryCore)
	handler(w, r)
}

// getCategoryCore contains the core business logic for getting a single category.
func (h *CategoryHandlerWithPipeline) getCategoryCore(w http.ResponseWriter, r *http.Request) {
	userID, ok := middleware.GetUserIDFromContext(r.Context())
	if !ok {
		api.Error(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	categoryID := chi.URLParam(r, "categoryId")

	// Create and execute query
	categoryQuery, err := queries.NewGetCategoryQuery(userID, categoryID)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	result, err := h.categoryQueryService.GetCategory(r.Context(), categoryQuery)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	// Convert and respond
	response := h.converter.FromCategoryView(result.Category)
	api.Success(w, http.StatusOK, response)
}

// ============================================================================
// COMMAND HANDLERS (WRITE OPERATIONS)
// ============================================================================

// CreateCategory handles POST /api/categories using command pipeline with validation.
func (h *CategoryHandlerWithPipeline) CreateCategory(w http.ResponseWriter, r *http.Request) {
	// Build pipeline with specific validation for create operations
	pipeline := middleware.NewPipelineBuilder(h.logger).
		WithErrorRecovery().
		WithLogging().
		WithAuthentication().
		WithServiceAvailability("CategoryService", func() bool { return h.categoryService != nil }).
		WithValidation(h.validateCreateCategoryRequest).
		Build()

	handler := pipeline.Build(h.createCategoryCore)
	handler(w, r)
}

// validateCreateCategoryRequest validates create category requests.
func (h *CategoryHandlerWithPipeline) validateCreateCategoryRequest(r *http.Request) error {
	_, validationResult := h.validator.ValidateCreateCategoryRequest(r)
	if !validationResult.IsValid {
		return fmt.Errorf(h.validator.FormatValidationErrors(validationResult.Errors))
	}
	return nil
}

// createCategoryCore contains the core business logic for creating categories.
func (h *CategoryHandlerWithPipeline) createCategoryCore(w http.ResponseWriter, r *http.Request) {
	userID, ok := middleware.GetUserIDFromContext(r.Context())
	if !ok {
		api.Error(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	// Re-validate to get the parsed request (validation middleware only validates)
	req, _ := h.validator.ValidateCreateCategoryRequest(r)

	// Create and execute command
	cmd, err := commands.NewCreateCategoryCommand(userID, req.Title, req.Description)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	result, err := h.categoryService.CreateCategory(r.Context(), cmd)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	// Convert and respond
	response := h.converter.FromCategoryView(result.Category)
	api.Success(w, http.StatusCreated, response)
}

// UpdateCategory handles PUT /api/categories/{categoryId} using command pipeline.
func (h *CategoryHandlerWithPipeline) UpdateCategory(w http.ResponseWriter, r *http.Request) {
	// Build pipeline with specific validation for update operations
	pipeline := middleware.NewPipelineBuilder(h.logger).
		WithErrorRecovery().
		WithLogging().
		WithAuthentication().
		WithServiceAvailability("CategoryService", func() bool { return h.categoryService != nil }).
		WithValidation(h.validateUpdateCategoryRequest).
		Build()

	handler := pipeline.Build(h.updateCategoryCore)
	handler(w, r)
}

// validateUpdateCategoryRequest validates update category requests.
func (h *CategoryHandlerWithPipeline) validateUpdateCategoryRequest(r *http.Request) error {
	_, validationResult := h.validator.ValidateUpdateCategoryRequest(r)
	if !validationResult.IsValid {
		return fmt.Errorf(h.validator.FormatValidationErrors(validationResult.Errors))
	}
	return nil
}

// updateCategoryCore contains the core business logic for updating categories.
func (h *CategoryHandlerWithPipeline) updateCategoryCore(w http.ResponseWriter, r *http.Request) {
	userID, ok := middleware.GetUserIDFromContext(r.Context())
	if !ok {
		api.Error(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	categoryID := chi.URLParam(r, "categoryId")
	req, _ := h.validator.ValidateUpdateCategoryRequest(r)

	// Create and execute command
	cmd, err := commands.NewUpdateCategoryCommand(userID, categoryID)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	cmd.WithTitle(req.Title).WithDescription(req.Description)

	result, err := h.categoryService.UpdateCategory(r.Context(), cmd)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	api.Success(w, http.StatusOK, map[string]interface{}{
		"message":    "Category updated successfully",
		"categoryId": result.Category.ID,
	})
}

// DeleteCategory handles DELETE /api/categories/{categoryId} using command pipeline.
func (h *CategoryHandlerWithPipeline) DeleteCategory(w http.ResponseWriter, r *http.Request) {
	handler := h.commandPipeline.Build(h.deleteCategoryCore)
	handler(w, r)
}

// deleteCategoryCore contains the core business logic for deleting categories.
func (h *CategoryHandlerWithPipeline) deleteCategoryCore(w http.ResponseWriter, r *http.Request) {
	userID, ok := middleware.GetUserIDFromContext(r.Context())
	if !ok {
		api.Error(w, http.StatusUnauthorized, "Authentication required")
		return
	}

	categoryID := chi.URLParam(r, "categoryId")

	// Create and execute command
	cmd, err := commands.NewDeleteCategoryCommand(userID, categoryID)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	_, err = h.categoryService.DeleteCategory(r.Context(), cmd)
	if err != nil {
		handleServiceError(w, err)
		return
	}

	w.WriteHeader(http.StatusNoContent)
}

// ============================================================================
// DEMONSTRATION OF PIPELINE EXTENSIBILITY
// ============================================================================

// AddCustomMiddleware demonstrates how to extend the pipeline without modifying existing code.
// This method follows the Open/Closed Principle by allowing extension through configuration.
func (h *CategoryHandlerWithPipeline) AddCustomMiddleware(name string, priority int, fn middleware.MiddlewareFunc) {
	h.queryPipeline.AddFunc(name, priority, fn)
	h.commandPipeline.AddFunc(name, priority, fn)
}

// CreateSpecializedPipeline demonstrates creating custom pipelines for specific use cases.
func (h *CategoryHandlerWithPipeline) CreateSpecializedPipeline() *middleware.Pipeline {
	return middleware.NewPipelineBuilder(h.logger).
		WithErrorRecovery().
		WithLogging().
		WithAuthentication().
		WithCustomFunc("RateLimiting", 12, h.rateLimitMiddleware).
		WithCustomFunc("Caching", 25, h.cachingMiddleware).
		Build()
}

// rateLimitMiddleware is an example of a custom middleware function.
func (h *CategoryHandlerWithPipeline) rateLimitMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Rate limiting logic here
		next(w, r)
	}
}

// cachingMiddleware is another example of a custom middleware function.
func (h *CategoryHandlerWithPipeline) cachingMiddleware(next http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// Caching logic here
		next(w, r)
	}
}
